# AD Editor: предложение по проекту совместной разработки Architecture Document

## 1) Цель и ограничения

Проект предназначен для небольшой команды архитекторов (до 10 человек), которая совместно ведёт Architecture Document (AD) для крупных систем в инвестиционном банке. Основные рамки:

- ориентация на ISO/IEC/IEEE 42010 как на каркас описания архитектуры;
- использование MODAF-подобных представлений и артефактов там, где это уместно;
- хранение исходников AD в YAML + Git как «источник истины»;
- фокус на текстовой архитектуре, решения и обоснования (диаграммы — во внешних инструментах по ссылкам);
- формирование финального документа в Markdown/HTML из параметров.

## 2) Предлагаемая архитектура решения (MVP)

### 2.1 Компоненты

1. **Spec repository (Git)**
   - хранит YAML-данные по нескольким архитектурам;
   - базовая структура может быть такой:

   ```text
   ad-specs/
     architecture-a/
       stakeholders.yaml
       concerns.yaml
       capabilities.yaml
       service_levels.yaml
       risks.yaml
       dictionaries.yaml
       metadata.yaml
     architecture-b/
       ...
   ```

2. **Backend (Python service)**
   - API для чтения/записи YAML;
   - API для операций Git (branch/create/delete/commit/push);
   - orchestration генерации AD-документа (вызов текущего рендерера `tools/adtool.py`);
   - валидация ссылочной целостности и схем.

3. **Frontend (Web UI)**
   - список архитектур;
   - формы редактирования сущностей (stakeholders, concerns, risks, capabilities, glossary и пр.);
   - экран Git-операций (выбор ветки, коммит, push, история);
   - кнопка «Сгенерировать AD» и просмотр результата.

4. **Document renderer**
   - существующий скрипт `tools/adtool.py` уже покрывает валидацию и генерацию Markdown;
   - добавить тонкую обвязку в сервисе: выбор архитектуры + целевой ветки + путь вывода.

### 2.2 Ключевые сущности домена

Для соответствия ISO 42010 в модели должны быть явно представлены:

- **Stakeholders**;
- **Concerns**;
- **Architecture decisions / rationales** (рекомендуется добавить отдельный YAML, например `decisions.yaml`);
- **Views / viewpoints** (минимум метаданные и привязки к concerns, даже если диаграмма внешняя);
- **Risks** и связи с concerns/capabilities/service levels;
- **Dictionary / glossary** для единообразных терминов.

### 2.3 Рекомендуемый API-контур (минимальный)

- `GET /architectures` — список архитектур;
- `GET /architectures/{id}/spec/{entity}` — получить YAML-сущность;
- `PUT /architectures/{id}/spec/{entity}` — сохранить YAML-сущность;
- `POST /architectures/{id}/validate` — запустить валидацию;
- `POST /architectures/{id}/build` — сгенерировать AD (md/html);
- `GET /git/branches` — список веток;
- `POST /git/checkout` — переключиться на ветку;
- `POST /git/branch` — создать ветку;
- `DELETE /git/branch/{name}` — удалить ветку;
- `POST /git/commit` — закоммитить изменения;
- `POST /git/push` — отправить в remote.

## 3) Модель работы команды

Для команды до 10 человек хорошо работает простой flow:

1. Архитектор создаёт feature-ветку под изменение AD.
2. В UI редактирует YAML-артефакты.
3. Запускает валидацию + генерацию AD.
4. Делает commit/push из UI.
5. Дальше ревью и merge выполняются вне системы (как вы и указали).

## 4) Что важно сделать в первую очередь (roadmap)

### Этап 1 — Hardening текущего генератора

- ввести JSON Schema/Pydantic-схемы для всех YAML;
- добавить `decisions.yaml`, `views.yaml`, `glossary.yaml`;
- улучшить отчёт о валидации (чтобы UI мог показывать ошибки по полям).

### Этап 2 — Backend API

- CRUD для сущностей;
- атомарная запись YAML;
- безопасная обвязка над git-командами (whitelist операций, понятные ошибки).

### Этап 3 — UI для архитекторов

- табличные/формовые редакторы сущностей;
- diff preview перед commit;
- build/preview AD-документа.

### Этап 4 — Нефункциональные требования

- аудит действий (кто/когда поменял параметр и создал commit);
- role-based доступ (read/write/admin);
- резервные копии и защита от повреждения YAML.

## 5) Ответ на вопрос: существуют ли такие инструменты?

Да, частичные аналоги есть, но обычно они закрывают только часть ваших требований:

1. **Sparx Enterprise Architect / Cameo / Capella / BiZZdesign / MEGA HOPEX**
   - сильны в моделировании и репозиториях архитектуры;
   - часто «тяжёлые» и менее git-native по сравнению с YAML-first подходом;
   - обычно больше акцент на моделях/диаграммах, а не на developer-style text-as-code.

2. **Structurizr DSL / C4 tooling / docs-as-code связки**
   - хорошо дружат с Git и review-процессом;
   - отлично для текстовой архитектуры и версионирования;
   - но не дают «из коробки» полноценную ISO 42010 + MODAF governance-модель.

3. **Archi + ArchiMate + Git-плагины**
   - open-source и достаточно популярен в EA-среде;
   - ближе к моделированию, UI и диаграммам, а не к YAML-формикам и собственному серверу.

4. **Backstage (TechDocs/каталог) + кастомные плагины**
   - платформа для порталов engineering knowledge;
   - можно расширить под AD, но потребуется значимая кастомизация.

**Вывод:** ваш замысел (YAML + Git + web-редактор + рендер AD) реалистичен и востребован, особенно для небольших архитектурных команд, которым важны контроль версий, прозрачность изменений и интеграция с существующим инженерным процессом.

## 6) Как использовать текущий репозиторий уже сейчас

Текущий рендерер можно запускать на примере в `examples/`:

```bash
python3 tools/adtool.py validate examples --report examples/validation_report.json
python3 tools/adtool.py build examples --out examples/AD_codified.md
```

Это уже даёт:

- базовую структурную валидацию YAML;
- отчёт с проблемами/пробелами;
- детерминированную сборку AD в Markdown.

Далее достаточно добавить web-обвязку и git-api слой.
